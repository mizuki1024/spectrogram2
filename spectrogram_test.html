<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spectrogram Visualizer - Standalone</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #0a0a0a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            color: white;
            max-width: 300px;
        }

        #controls h2 {
            margin: 0 0 15px 0;
            color: #00ff88;
        }

        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: inline-block;
            width: 100px;
            font-size: 12px;
        }

        button {
            background: #00ff88;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            margin: 2px;
            font-weight: bold;
            color: black;
        }

        button:hover {
            background: #00cc6a;
        }

        button.recording {
            background: #ff4444;
            color: white;
        }

        #spectrum-canvas {
            width: 100%;
            height: 100%;
        }

        .vowel-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 10px;
        }

        .vowel-btn {
            padding: 5px 8px;
            font-size: 11px;
            min-width: 40px;
        }

        #status {
            position: absolute;
            top: 20px;
            right: 760px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            color: white;
            min-width: 300px;
        }

        .formant-info {
            font-size: 12px;
            color: #88ff88;
            margin-top: 5px;
        }

        #canvas2d {
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, #0a0a0a, #1a1a2e);
        }

        .debug-info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: #00ff88;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 11px;
        }

        #formant-plot {
            position: absolute;
            top: 20px;
            right: 400px;
            width: 320px;
            height: 270px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff88;
            border-radius: 5px;
            z-index: 1000;
        }

        #formant-plot canvas {
            width: 100%;
            height: 100%;
        }



        .plot-title {
            position: absolute;
            top: 5px;
            left: 10px;
            color: white;
            font-size: 12px;
            font-weight: bold;
            z-index: 1001;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas2d"></canvas>

        <div id="controls">
            <h2>üéØ Audio Spectrogram</h2>

            <div class="control-group">
                <button id="recordBtn">üéôÔ∏è Start Recording</button>
                <button id="resetBtn">Reset</button>
            </div>

            <div class="control-group">
                <label>Target Vowel:</label>
                <div class="vowel-buttons">
                    <button class="vowel-btn" data-vowel="i">„ÅÑ (i)</button>
                    <button class="vowel-btn" data-vowel="e">„Åà (e)</button>
                    <button class="vowel-btn" data-vowel="a">„ÅÇ (a)</button>
                    <button class="vowel-btn" data-vowel="o">„Åä (o)</button>
                    <button class="vowel-btn" data-vowel="u">„ÅÜ (u)</button>
                </div>
            </div>

        </div>

        <div id="status">
            <div><strong>Status:</strong> <span id="statusText">Click Start Recording</span></div>
            <div><strong>Target:</strong> <span id="targetVowel">√¶ (cat)</span></div>
            <div class="formant-info">
                <strong>Audio Level:</strong> <span id="audioLevel">0</span>
            </div>
            <div class="formant-info">
                <strong>Formants:</strong> F1=<span id="f1Value">-</span>Hz, F2=<span id="f2Value">-</span>Hz
            </div>
            <div class="formant-info">
                <strong>Frequency Peak:</strong> <span id="freqPeak">-</span>Hz
            </div>
            <div class="formant-info">
                <strong>Detected:</strong> <span id="detectedVowel">-</span>
            </div>
        </div>

        <div class="debug-info" id="debugInfo">
            Debug: Ready
        </div>

        <div id="formant-plot">
            <div class="plot-title">Formant Space</div>
            <canvas id="formant-canvas" width="200" height="150"></canvas>
        </div>

    </div>

    <script>
        // „Ç∞„É≠„Éº„Éê„É´Â§âÊï∞
        let canvas, ctx;
        let formantCanvas, formantCtx;
        let analyser, microphone, audioContext;
        let animationId;
        let isRecording = false;
        let currentVowel = 'i';
        let spectrogramData = [];
        let maxSpectrogramHistory = 200;
        let mediaRecorder;
        let stream;
        let ws;
        let recordingInterval;

        // Êó•Êú¨Ë™ûÊØçÈü≥„Éá„Éº„Çø
        const VOWELS = {
            'i': {
                name: '„ÅÑ',
                color: '#FF0000',
                f1: 324.0,
                f2: 2426.3
            },
            'e': {
                name: '„Åà',
                color: '#00FF00',
                f1: 501.7,
                f2: 2064.6
            },
            'a': {
                name: '„ÅÇ',
                color: '#0000FF',
                f1: 633.9,
                f2: 1087.5
            },
            'o': {
                name: '„Åä',
                color: '#FFFF00',
                f1: 445.1,
                f2: 854.2
            },
            'u': {
                name: '„ÅÜ',
                color: '#FF00FF',
                f1: 343.8,
                f2: 1281.0
            }
        };

        // HSV„Åã„ÇâRGBÂ§âÊèõÔºàChrome Music LabÂÜçÁèæÔºâ
        function hsvToRgb(h, s, v) {
            h = ((h % 360) + 360) % 360; // 0-360„Å´Ê≠£Ë¶èÂåñ
            s = Math.max(0, Math.min(1, s));
            v = Math.max(0, Math.min(1, v));

            const c = v * s;
            const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
            const m = v - c;

            let r, g, b;
            if (h < 60) {
                r = c; g = x; b = 0;
            } else if (h < 120) {
                r = x; g = c; b = 0;
            } else if (h < 180) {
                r = 0; g = c; b = x;
            } else if (h < 240) {
                r = 0; g = x; b = c;
            } else if (h < 300) {
                r = x; g = 0; b = c;
            } else {
                r = c; g = 0; b = x;
            }

            return [
                Math.round((r + m) * 255),
                Math.round((g + m) * 255),
                Math.round((b + m) * 255)
            ];
        }

        // ÂàùÊúüÂåñ
        function init() {
            console.log("Initializing...");

            canvas = document.getElementById('canvas2d');
            ctx = canvas.getContext('2d');

            // „Éï„Ç©„É´„Éû„É≥„Éà„Éó„É≠„ÉÉ„ÉàÂàùÊúüÂåñ
            formantCanvas = document.getElementById('formant-canvas');
            formantCtx = formantCanvas.getContext('2d');

                // „Ç≠„É£„É≥„Éê„Çπ„Çµ„Ç§„Ç∫„ÇíË®≠ÂÆö
            resizeCanvas();

            setupEventListeners();

            // „ÉÜ„Çπ„ÉàÊèèÁîª
            drawTestPattern();
            drawFormantPlot();

            console.log("Initialization complete");
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        function drawTestPattern() {
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // „ÉÜ„Çπ„Éà„Éë„Çø„Éº„É≥ÊèèÁîª
            ctx.fillStyle = '#00ff88';
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Audio Spectrogram Visualizer', canvas.width / 2, canvas.height / 2 - 50);

            ctx.fillStyle = '#888';
            ctx.font = '16px Arial';
            ctx.fillText('Click "Start Recording" to begin', canvas.width / 2, canvas.height / 2);
            ctx.fillText('No external libraries required', canvas.width / 2, canvas.height / 2 + 30);
        }

        async function startAudioCapture() {
            try {
                console.log("Starting audio capture...");
                document.getElementById('debugInfo').textContent = "Debug: Requesting microphone access...";

                // Web Audio APIÂàùÊúüÂåñ
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                console.log("AudioContext state:", audioContext.state);

                // „Éû„Ç§„ÇØ„Ç¢„ÇØ„Çª„ÇπË¶ÅÊ±Ç
                stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false,
                        sampleRate: 44100
                    }
                });

                console.log("Microphone access granted");
                document.getElementById('debugInfo').textContent = "Debug: Microphone access granted";

                microphone = audioContext.createMediaStreamSource(stream);

                // „Ç¢„Éä„É©„Ç§„Ç∂„Éº‰ΩúÊàê
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                analyser.smoothingTimeConstant = 0.1;

                microphone.connect(analyser);

                console.log("Audio setup completed");
                document.getElementById('debugInfo').textContent = "Debug: Audio setup complete";

                return true;
            } catch (error) {
                console.error('Audio initialization failed:', error);
                document.getElementById('statusText').textContent = 'Audio Error: ' + error.message;
                document.getElementById('debugInfo').textContent = "Debug: Audio error - " + error.message;
                return false;
            }
        }

        function setupEventListeners() {
            // Èå≤Èü≥„Éú„Çø„É≥
            document.getElementById('recordBtn').addEventListener('click', toggleRecording);


            // ÊØçÈü≥ÈÅ∏Êäû
            document.querySelectorAll('.vowel-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    currentVowel = btn.dataset.vowel;
                    const vowelData = VOWELS[currentVowel];
                    document.getElementById('targetVowel').textContent =
                        `${currentVowel} (${vowelData.name})`;

                    // „Éó„É≠„ÉÉ„ÉàÊõ¥Êñ∞
                    drawFormantPlot();

                    console.log(`Target vowel changed to: ${currentVowel}`);
                });
            });


            // „É™„Çª„ÉÉ„Éà
            document.getElementById('resetBtn').addEventListener('click', () => {
                spectrogramData = [];
                drawTestPattern();
            });

            // „Ç¶„Ç£„É≥„Éâ„Ç¶„É™„Çµ„Ç§„Ç∫
            window.addEventListener('resize', resizeCanvas);
        }

        async function toggleRecording() {
            const btn = document.getElementById('recordBtn');
            console.log("Toggle recording, current state:", isRecording);

            if (!isRecording) {
                // Èå≤Èü≥ÈñãÂßã
                document.getElementById('statusText').textContent = 'Initializing...';

                const success = await startAudioCapture();
                if (!success) {
                    return;
                }

                // REST API„Çí‰ΩøÁî®„Åó„Å¶„Éï„Ç©„É´„Éû„É≥„ÉàÂàÜÊûê
                // „É°„Éá„Ç£„Ç¢„É¨„Ç≥„Éº„ÉÄ„Éº„ÇíË®≠ÂÆöÔºà„Çà„ÇäËªΩÈáè„Å™Ë®≠ÂÆöÔºâ
                let audioChunks = [];
                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'audio/webm;codecs=opus',
                    audioBitsPerSecond: 32000  // ‰Ωé„Éì„ÉÉ„Éà„É¨„Éº„Éà„ÅßËªΩÈáèÂåñ
                });
                mediaRecorder.ondataavailable = function(e) {
                    if (e.data.size > 0) {
                        audioChunks.push(e.data);
                    }
                };
                mediaRecorder.onstop = async function() {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    audioChunks = []; // Reset for next recording

                    // Èü≥Â£∞„É¨„Éô„É´„Åå‰Ωé„ÅÑÂ†¥Âêà„ÅØAPIÂëº„Å≥Âá∫„Åó„Çí„Çπ„Ç≠„ÉÉ„Éó
                    const currentLevel = parseInt(document.getElementById('audioLevel').textContent) || 0;
                    if (currentLevel < 10) {
                        console.log('Audio level too low, skipping API call');
                        return;
                    }

                    // Convert to WAV and send to REST API
                    try {
                        const arrayBuffer = await audioBlob.arrayBuffer();
                        const base64Audio = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));

                        const response = await fetch('/extract_formants', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({ audio: base64Audio })
                        });

                        if (response.ok) {
                            const data = await response.json();
                            if (data.success) {
                                // „Éï„Ç©„É´„Éû„É≥„Éà„Éá„Éº„Çø„ÇíÊõ¥Êñ∞
                                currentF1 = data.f1;
                                currentF2 = data.f2;
                                document.getElementById('f1Value').textContent = Math.round(data.f1);
                                document.getElementById('f2Value').textContent = Math.round(data.f2);
                                drawFormantPlot();
                            }
                        }
                    } catch (error) {
                        console.error('Error analyzing audio:', error);
                    }
                };

                isRecording = true;
                btn.textContent = '‚èπÔ∏è Stop Recording';
                btn.classList.add('recording');
                document.getElementById('statusText').textContent = 'Recording...';

                // AudioContext„ÇíÂÜçÈñã
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }

                // Èå≤Èü≥ÈñãÂßã
                mediaRecorder.start();
                // „É©„Ç∞ËªΩÊ∏õ„ÅÆ„Åü„ÇÅ„ÄÅAPIÂëº„Å≥Âá∫„ÅóÈñìÈöî„Çí„Åï„Çâ„Å´Âª∂Èï∑Ôºà5Áßí„Åî„Å®Ôºâ
                recordingInterval = setInterval(() => {
                    mediaRecorder.stop();
                    mediaRecorder.start();
                }, 5000);

                // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÈñãÂßã
                animate();

            } else {
                // Èå≤Èü≥ÂÅúÊ≠¢
                isRecording = false;
                btn.textContent = 'üéôÔ∏è Start Recording';
                btn.classList.remove('recording');
                document.getElementById('statusText').textContent = 'Stopped';

                // „Ç§„É≥„Çø„Éº„Éê„É´„Çí„ÇØ„É™„Ç¢
                if (recordingInterval) {
                    clearInterval(recordingInterval);
                }

                // „É°„Éá„Ç£„Ç¢„É¨„Ç≥„Éº„ÉÄ„Éº„ÇíÂÅúÊ≠¢
                if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                    mediaRecorder.stop();
                }

                // WebSocketÊé•Á∂ö„ÅØ‰ΩøÁî®„Åó„Å™„ÅÑ„Åü„ÇÅÂâäÈô§

                // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÂÅúÊ≠¢
                if (animationId) {
                    cancelAnimationFrame(animationId);
                }

                // „Çπ„Éà„É™„Éº„É†ÂÅúÊ≠¢
                if (microphone && microphone.mediaStream) {
                    microphone.mediaStream.getTracks().forEach(track => track.stop());
                }
            }
        }


        function animate() {
            if (!isRecording) return;

            animationId = requestAnimationFrame(animate);

            updateSpectrogram();
            drawSpectrogram();
            
            // „Çà„ÇäÈ†ªÁπÅ„Å´„Éï„Ç©„É´„Éû„É≥„Éà„Éó„É≠„ÉÉ„Éà„ÇíÊõ¥Êñ∞
            drawFormantPlot();
        }

        function updateSpectrogram() {
            if (!analyser) return;

            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);

            // Èü≥Â£∞„É¨„Éô„É´Ë®àÁÆó
            let sum = 0;
            let maxVal = 0;
            let maxIndex = 0;

            for (let i = 0; i < bufferLength; i++) {
                sum += dataArray[i];
                if (dataArray[i] > maxVal) {
                    maxVal = dataArray[i];
                    maxIndex = i;
                }
            }

            const avgLevel = Math.round(sum / bufferLength);
            const peakFreq = Math.round((maxIndex / bufferLength) * (audioContext.sampleRate / 2));

            // UIÊõ¥Êñ∞
            document.getElementById('audioLevel').textContent = avgLevel;
            document.getElementById('freqPeak').textContent = peakFreq;
            document.getElementById('debugInfo').textContent =
                `Debug: Level=${avgLevel}, Peak=${peakFreq}Hz, Max=${maxVal}`;

            // „Çπ„Éö„ÇØ„Éà„É≠„Ç∞„É©„É†„Éá„Éº„Çø„Å´ËøΩÂä†
            spectrogramData.push(Array.from(dataArray));

            // Â±•Ê≠¥Âà∂Èôê
            if (spectrogramData.length > maxSpectrogramHistory) {
                spectrogramData.shift();
            }

            // Á∞°ÊòìÊØçÈü≥ÂàÜÈ°û
            classifyVowel(dataArray);
        }

        function drawSpectrogram() {
            if (spectrogramData.length === 0) return;

            const width = canvas.width;
            const height = canvas.height;

            // ËÉåÊôØ„ÇØ„É™„Ç¢
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, width, height);

            const timeSlices = spectrogramData.length;
            const freqBins = spectrogramData[0].length;

            const sliceWidth = width / timeSlices;
            const binHeight = height / freqBins;

            // „Çπ„Éö„ÇØ„Éà„É≠„Ç∞„É©„É†ÊèèÁîª
            for (let t = 0; t < timeSlices; t++) {
                const x = t * sliceWidth;

                for (let f = 0; f < freqBins; f++) {
                    const y = height - (f + 1) * binHeight; // Âë®Ê≥¢Êï∞„ÇíÂèçËª¢
                    const amplitude = spectrogramData[t][f];

                    if (amplitude > 10) { // „Éé„Ç§„Ç∫„Éï„Ç£„É´„Çø
                        // Chrome Music LabÈ¢®„Ç´„É©„Éº„Éû„ÉÉ„Éî„É≥„Ç∞
                        const normalizedAmp = amplitude / 255.0;
                        const hue = 360 - (normalizedAmp * 360); // 360Â∫¶„Åã„Çâ0Â∫¶„Å∏
                        const [r, g, b] = hsvToRgb(hue, 1.0, normalizedAmp);

                        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                        ctx.fillRect(x, y, sliceWidth + 1, binHeight + 1);
                    }
                }
            }

            // „Éï„Ç©„É´„Éû„É≥„ÉàÁ∑ö„ÇíÊèèÁîª
            if (currentF1 > 0 && currentF2 > 0) {
                const maxFreq = 4000; // Ë°®Á§∫„Åô„ÇãÊúÄÂ§ßÂë®Ê≥¢Êï∞

                // F1Á∑ö (Ëµ§)
                const f1Y = height - (currentF1 / maxFreq) * height;
                if (f1Y > 0 && f1Y < height) {
                    ctx.strokeStyle = '#ff4444';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(0, f1Y);
                    ctx.lineTo(width, f1Y);
                    ctx.stroke();

                    // F1„É©„Éô„É´
                    ctx.fillStyle = '#ff4444';
                    ctx.font = 'bold 14px Arial';
                    ctx.fillText(`F1: ${Math.round(currentF1)}Hz`, width - 120, f1Y - 5);
                }

                // F2Á∑ö (ÈªÑ)
                const f2Y = height - (currentF2 / maxFreq) * height;
                if (f2Y > 0 && f2Y < height) {
                    ctx.strokeStyle = '#ffff44';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(0, f2Y);
                    ctx.lineTo(width, f2Y);
                    ctx.stroke();

                    // F2„É©„Éô„É´
                    ctx.fillStyle = '#ffff44';
                    ctx.font = 'bold 14px Arial';
                    ctx.fillText(`F2: ${Math.round(currentF2)}Hz`, width - 120, f2Y - 5);
                }

                // Á∑ö„Çπ„Çø„Ç§„É´„Çí„É™„Çª„ÉÉ„Éà
                ctx.setLineDash([]);
            }

            // ÊØçÈü≥„Éû„Éº„Ç´„ÉºÔºàÁêÜÊÉ≥ÁöÑ„Å™„Éï„Ç©„É´„Éû„É≥„Éà‰ΩçÁΩÆÔºâ
            const targetVowel = VOWELS[currentVowel];
            if (targetVowel) {
                const maxFreq = 4000;
                const targetF1Y = height - (targetVowel.f1 / maxFreq) * height;
                const targetF2Y = height - (targetVowel.f2 / maxFreq) * height;

                if (targetF1Y > 0 && targetF1Y < height) {
                    ctx.strokeStyle = '#00ff88';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([2, 8]);
                    ctx.beginPath();
                    ctx.moveTo(0, targetF1Y);
                    ctx.lineTo(width, targetF1Y);
                    ctx.stroke();

                    ctx.fillStyle = '#00ff88';
                    ctx.font = '12px Arial';
                    ctx.fillText(`Target F1: ${targetVowel.f1}Hz`, 10, targetF1Y - 5);
                }

                if (targetF2Y > 0 && targetF2Y < height) {
                    ctx.strokeStyle = '#00ff88';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([2, 8]);
                    ctx.beginPath();
                    ctx.moveTo(0, targetF2Y);
                    ctx.lineTo(width, targetF2Y);
                    ctx.stroke();

                    ctx.fillStyle = '#00ff88';
                    ctx.font = '12px Arial';
                    ctx.fillText(`Target F2: ${targetVowel.f2}Hz`, 10, targetF2Y - 5);
                }

                ctx.setLineDash([]);
            }

            // „Éï„É¨„Éº„É†ÊÉÖÂ†±Ë°®Á§∫
            ctx.fillStyle = '#00ff88';
            ctx.font = '12px monospace';
            ctx.fillText(`Frames: ${timeSlices}, Freq bins: ${freqBins}`, 10, height - 10);
        }

        // „Ç∞„É≠„Éº„Éê„É´Â§âÊï∞„Å´„Éï„Ç©„É´„Éû„É≥„ÉàÂÄ§„ÇíËøΩÂä†
        let currentF1 = 0, currentF2 = 0;



        function extractFormants(dataArray) {
            // „Çà„ÇäÈ´òÁ≤æÂ∫¶„Å™„Éï„Ç©„É´„Éû„É≥„ÉàÊé®ÂÆö
            const sampleRate = audioContext.sampleRate;
            const binSize = sampleRate / (2 * dataArray.length);

            // „Çπ„É†„Éº„Ç∏„É≥„Ç∞Âá¶ÁêÜ
            const smoothedData = new Float32Array(dataArray.length);
            for (let i = 1; i < dataArray.length - 1; i++) {
                smoothedData[i] = (dataArray[i-1] + dataArray[i] * 2 + dataArray[i+1]) / 4;
            }

            // „Éî„Éº„ÇØÊ§úÂá∫Èñ¢Êï∞Ôºà„Çà„ÇäÊïèÊÑü„Å´Ë®≠ÂÆöÔºâ
            function findPeaks(data, minAmplitude = 10) { // ÈñæÂÄ§„Çí‰∏ã„Åí„Çã
                const peaks = [];
                for (let i = 1; i < data.length - 1; i++) {
                    if (data[i] > data[i-1] && data[i] > data[i+1] && data[i] > minAmplitude) {
                        peaks.push({
                            index: i,
                            frequency: i * binSize,
                            amplitude: data[i]
                        });
                    }
                }
                return peaks.sort((a, b) => b.amplitude - a.amplitude);
            }

            const peaks = findPeaks(smoothedData);

            // F1ÂÄôË£ú (200-1000Hz)
            const f1Candidates = peaks.filter(p =>
                p.frequency >= 200 && p.frequency <= 1000
            );

            // F2ÂÄôË£ú (800-3000Hz) - F1„Çà„ÇäÈ´ò„ÅÑÂë®Ê≥¢Êï∞
            const f2Candidates = peaks.filter(p =>
                p.frequency >= 800 && p.frequency <= 3000
            );

            // ÊúÄ„ÇÇÂº∑„ÅÑ„Éî„Éº„ÇØ„ÇíÈÅ∏Êäû
            let f1 = f1Candidates.length > 0 ? f1Candidates[0].frequency : 0;
            let f2 = f2Candidates.find(p => p.frequency > f1)?.frequency || 0;

            // ÁÑ°Èü≥Ê§úÂá∫ (ÈñæÂÄ§„ÇíË™øÊï¥„Åó„Å¶„ÄÅ„Çà„ÇäÊïèÊÑü„Å´Èü≥Â£∞„ÇíÊ§úÂá∫)
            const averageAmplitude = smoothedData.reduce((sum, val) => sum + val, 0) / smoothedData.length;
            const maxAmplitude = Math.max(...smoothedData);
            
            // „Çà„ÇäÊïèÊÑü„Å™ÁÑ°Èü≥Âà§ÂÆöÔºàÈñæÂÄ§„Çí‰∏ã„Åí„Å¶Èü≥Â£∞„ÇíÊ§úÂá∫„Åó„ÇÑ„Åô„Åè„Åô„ÇãÔºâ
            if (averageAmplitude < 2 || maxAmplitude < 30) { // ÁÑ°Èü≥ÈñæÂÄ§„Çí‰∏ã„Åí„Çã
                return { f1: 0, f2: 0 };
            }

            // „Éï„Ç©„É´„Éû„É≥„ÉàËøΩË∑°Ôºà„Çà„ÇäÂèçÂøúÁöÑ„Å´Ë®≠ÂÆöÔºâ
            const smoothingFactor = 0.5; // „Çà„ÇäÂèçÂøúÁöÑ„Å´
            if (f1 > 0) {
                currentF1 = currentF1 === 0 ? f1 : currentF1 * smoothingFactor + f1 * (1 - smoothingFactor);
            }
            if (f2 > 0) {
                currentF2 = currentF2 === 0 ? f2 : currentF2 * smoothingFactor + f2 * (1 - smoothingFactor);
            }

            // „Éï„Ç©„É´„Éû„É≥„ÉàÂÄ§„ÇíÂõõÊç®‰∫îÂÖ•
            return { 
                f1: Math.round(currentF1), 
                f2: Math.round(currentF2)
            };
        }

        const F1_THRESHOLD = 150;  // „Çà„ÇäÂØõÂÆπ„Å´Ë®≠ÂÆö
        const F2_THRESHOLD = 300;  // „Çà„ÇäÂØõÂÆπ„Å´Ë®≠ÂÆö
        const THRESHOLD = 200;     // „Çà„ÇäÂØõÂÆπ„Å´Ë®≠ÂÆö

        function classifyVowel(dataArray) {
            // „Éï„Ç©„É´„Éû„É≥„ÉàÊé®ÂÆö
            const formants = extractFormants(dataArray);

            // UIÊõ¥Êñ∞
            document.getElementById('f1Value').textContent = formants.f1 || '-';
            document.getElementById('f2Value').textContent = formants.f2 || '-';

            // ÊØçÈü≥ÂàÜÈ°û
            if (formants.f1 > 0 && formants.f2 > 0) {
                let bestMatch = '…ô';
                let matched = false;

                for (const [vowel, data] of Object.entries(VOWELS)) {
                    const th_f1 = F1_THRESHOLD;
                    const th_f2 = F2_THRESHOLD;

                    if (Math.abs(formants.f1 - data.f1) <= th_f1 && 
                        Math.abs(formants.f2 - data.f2) <= th_f2) {
                        bestMatch = vowel;
                        matched = true;
                        break;
                    }
                }

                const isMatch = bestMatch === currentVowel;
                const confidence = matched ? 100 : 0;

                document.getElementById('detectedVowel').textContent =
                    `${bestMatch} (${VOWELS[bestMatch].name})${isMatch ? ' ‚úÖ' : ''} ${confidence}%`;
            } else {
                document.getElementById('detectedVowel').textContent = 'No clear vowel detected';
            }

            return formants;
        }

        function drawFormantPlot() {
            if (!formantCtx) return;

            const width = 200;
            const height = 200;

            // ËÉåÊôØ„ÇØ„É™„Ç¢
            formantCtx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            formantCtx.fillRect(0, 0, width, height);

            // F1-F2Á©∫Èñì„ÅÆÁØÑÂõ≤Ë®≠ÂÆöÔºàÁîªÂÉè„Å´Âêà„Çè„Åõ„Å¶Ë™øÊï¥Ôºâ
            const f1Min = 200, f1Max = 800;
            const f2Min = 500, f2Max = 3000;

            // Â∫ßÊ®ôÂ§âÊèõÈñ¢Êï∞ÔºàÈü≥ÈüªÂ≠¶ÁöÑÊÖ£Áøí„Å´Âæì„Å£„Å¶‰øÆÊ≠£Ôºâ
            function toPlotCoords(f1, f2) {
                // F2„ÅØÂ∑¶Âè≥ÂèçËª¢ÔºàÈ´ò„ÅÑÂÄ§„ÅåÂ∑¶ÂÅ¥Ôºâ
                const x = width - ((f2 - f2Min) / (f2Max - f2Min)) * width;
                // F1„ÅØ‰∏ä‰∏ãÂèçËª¢Ôºà‰Ωé„ÅÑÂÄ§„Åå‰∏äÂÅ¥Ôºâ
                const y = ((f1 - f1Min) / (f1Max - f1Min)) * height;
                return { x, y };
            }

            // Ëª∏„ÅÆÊèèÁîª
            formantCtx.strokeStyle = '#444';
            formantCtx.lineWidth = 1;
            formantCtx.setLineDash([]);

            // F2Ëª∏„ÅÆ„Ç∞„É™„ÉÉ„ÉâÔºàÂè≥„Åã„ÇâÂ∑¶„Å∏Ôºâ
            for (let f2 = 1000; f2 <= 2500; f2 += 500) {
                const x = width - ((f2 - f2Min) / (f2Max - f2Min)) * width;
                formantCtx.beginPath();
                formantCtx.moveTo(x, 0);
                formantCtx.lineTo(x, height);
                formantCtx.stroke();
            }

            // F1Ëª∏„ÅÆ„Ç∞„É™„ÉÉ„ÉâÔºà‰∏ä„Åã„Çâ‰∏ã„Å∏Ôºâ
            for (let f1 = 200; f1 <= 700; f1 += 100) {
                const y = ((f1 - f1Min) / (f1Max - f1Min)) * height;
                formantCtx.beginPath();
                formantCtx.moveTo(0, y);
                formantCtx.lineTo(width, y);
                formantCtx.stroke();
            }

            // Ëª∏„ÅÆÊï∞ÂÄ§„É©„Éô„É´„ÇíËøΩÂä†
            formantCtx.fillStyle = 'white';
            formantCtx.font = '10px Arial';
            formantCtx.textAlign = 'center';

            // F2Ëª∏„ÅÆÊï∞ÂÄ§Ôºà‰∏äÈÉ®Ôºâ
            for (let f2 = 1000; f2 <= 2500; f2 += 500) {
                const x = width - ((f2 - f2Min) / (f2Max - f2Min)) * width;
                formantCtx.fillText(f2.toString(), x, 15);
            }

            // F1Ëª∏„ÅÆÊï∞ÂÄ§ÔºàÂ∑¶ÂÅ¥Ôºâ
            formantCtx.textAlign = 'right';
            for (let f1 = 200; f1 <= 700; f1 += 100) {
                const y = ((f1 - f1Min) / (f1Max - f1Min)) * height;
                formantCtx.fillText(f1.toString(), 25, y + 4);
            }

            // ÁêÜÊÉ≥ÁöÑ„Å™ÊØçÈü≥‰ΩçÁΩÆ„ÇíÊèèÁîª
            for (const [vowel, data] of Object.entries(VOWELS)) {
                const coords = toPlotCoords(data.f1, data.f2);
                if (coords.x >= 0 && coords.x <= width && coords.y >= 0 && coords.y <= height) {
                    // ÊØçÈü≥ÂÜÜ
                    formantCtx.fillStyle = vowel === currentVowel ? '#00ff88' : data.color;
                    formantCtx.beginPath();
                    formantCtx.arc(coords.x, coords.y, vowel === currentVowel ? 8 : 4, 0, Math.PI * 2);
                    formantCtx.fill();

                    // ÊØçÈü≥„É©„Éô„É´
                    formantCtx.fillStyle = 'white';
                    formantCtx.font = '10px Arial';
                    formantCtx.textAlign = 'center';
                    formantCtx.fillText(data.name, coords.x, coords.y - 10);
                }
            }

            // ÁèæÂú®„ÅÆÁô∫Ë©±‰ΩçÁΩÆ„ÇíÊèèÁîª
            if (currentF1 > 0 && currentF2 > 0) {
                const coords = toPlotCoords(currentF1, currentF2);
                if (coords.x >= 0 && coords.x <= width && coords.y >= 0 && coords.y <= height) {
                    // ÁèæÂú®‰ΩçÁΩÆ„Éû„Éº„Ç´„Éº
                    formantCtx.fillStyle = '#ff4444';
                    formantCtx.beginPath();
                    formantCtx.arc(coords.x, coords.y, 6, 0, Math.PI * 2);
                    formantCtx.fill();

                    // Ëº™ÈÉ≠
                    formantCtx.strokeStyle = 'white';
                    formantCtx.lineWidth = 2;
                    formantCtx.beginPath();
                    formantCtx.arc(coords.x, coords.y, 6, 0, Math.PI * 2);
                    formantCtx.stroke();
                }
            }

            // Ëª∏„É©„Éô„É´
            formantCtx.fillStyle = 'white';
            formantCtx.font = '12px Arial';
            formantCtx.textAlign = 'center';
            formantCtx.fillText('F2 (Hz)', width / 2, height - 5);

            formantCtx.save();
            formantCtx.translate(10, height / 2);
            formantCtx.rotate(-Math.PI / 2);
            formantCtx.fillText('F1 (Hz)', 0, 0);
            formantCtx.restore();
        }
        // updateSpectrogramÈñ¢Êï∞„Çí‰øÆÊ≠£„Åó„Å¶„Éï„Ç©„É´„Éû„É≥„Éà„Éó„É≠„ÉÉ„Éà„ÇÇÊõ¥Êñ∞
        function updateSpectrogram() {
            if (!analyser) return;

            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);

            // Èü≥Â£∞„É¨„Éô„É´Ë®àÁÆó
            let sum = 0;
            let maxVal = 0;
            let maxIndex = 0;

            for (let i = 0; i < bufferLength; i++) {
                sum += dataArray[i];
                if (dataArray[i] > maxVal) {
                    maxVal = dataArray[i];
                    maxIndex = i;
                }
            }

            const avgLevel = Math.round(sum / bufferLength);
            const peakFreq = Math.round((maxIndex / bufferLength) * (audioContext.sampleRate / 2));

            // UIÊõ¥Êñ∞
            document.getElementById('audioLevel').textContent = avgLevel;
            document.getElementById('freqPeak').textContent = peakFreq;
            document.getElementById('debugInfo').textContent =
                `Debug: Level=${avgLevel}, Peak=${peakFreq}Hz, Max=${maxVal}`;

            // „Çπ„Éö„ÇØ„Éà„É≠„Ç∞„É©„É†„Éá„Éº„Çø„Å´ËøΩÂä†
            spectrogramData.push(Array.from(dataArray));

            // Â±•Ê≠¥Âà∂Èôê
            if (spectrogramData.length > maxSpectrogramHistory) {
                spectrogramData.shift();
            }

            // Á∞°ÊòìÊØçÈü≥ÂàÜÈ°û„Å®„Éï„Ç©„É´„Éû„É≥„Éà„Éó„É≠„ÉÉ„ÉàÊõ¥Êñ∞
            classifyVowel(dataArray);
            drawFormantPlot();
        }

        // ÂàùÊúüÂåñÂÆüË°å
        window.addEventListener('load', init);
    </script>
</body>
</html>